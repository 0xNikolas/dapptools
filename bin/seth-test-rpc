#!/usr/bin/env node
// seth-test-rpc -- run a command with a fake Ethereum RPC server
// Usage: seth test-rpc <command> [<args>]
// The canned RPC interactions are read from file descriptor 3.

var assert = require("assert")
var cp = require("child_process")
var fs = require("fs")
var http = require("http")

if (process.argv.length < 3) {
  cp.execSync("seth help test-rpc")
  process.exit(1)
}

var mocks = JSON.parse(fs.readFileSync("/dev/fd/3"))
var command = process.argv[2]
var args = process.argv.slice(3)

var server = http.createServer(handleRequest).listen(() => {
  cp.spawn(command, args, {
    stdio: "inherit", env: Object.assign({}, process.env, {
      ETH_RPC_URL: `localhost:${server.address().port}`
    }),
  }).on("close", status => process.exit(status))
})

function handleRequest(request, response) {
  slurp(request, json => {
    getMockResponse(JSON.parse(json), mock => {
      if (mock) {
        response.end(JSON.stringify(mock))
      } else {
        console.error(`# Unexpected RPC call:`)
        console.error(JSON.stringify(json, null, 2).replace(/^/gm, "#   "))
        console.error("#")
        response.end("missing mock response")
      }
    })
  })
}

function slurp(stream, callback) {
  var data = []
  stream.on("data", chunk => data.push(chunk))
  stream.on("end", () => callback(Buffer.concat(data).toString()))
}

function getMockResponse(request, callback) {
  var { jsonrpc, id, method, params } = request

  for (var i = 0; i < mocks.length; i++) {
    var [mockMethod, mockParams, result, error] = mocks[i]

    if (mockMethod == method && deepEqual(mockParams, params)) {
      moveToEnd(mocks, i)

      if (error) {
        callback({ jsonrpc, id, error })
      } else {
        callback({ jsonrpc, id, result })
      }

      return
    }
  }
}

function deepEqual(a, b) {
  try {
    assert.deepEqual(a, b)
    return true
  } catch (error) {
    return false
  }
}

function moveToEnd(array, index) {
  array.push(array[index])
  array.splice(index, 1)
}
